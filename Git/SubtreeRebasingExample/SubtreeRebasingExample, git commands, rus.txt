Обновление до актуальной версии BaseCode
Подготовительный этап
1. Обновление master ветки [ваш проект] из репозитория SurricataMirror
2. Обновление ветки локально
3. Перенос появившихся тегов BaseCode (делается независимо/отдельно от получения коммитов)
Основной этап
0. Сохранение предыдущих позиций dev- и релизных веток (каждой)
1. Перенос [ваш проект]_dev на новую позицию (на схеме - операция 1)
2. Перенос тегов c dev-ветки до перебазирования ([ваш проект]_dev_based_BaseCode_8.0.0-beta1) на новую перебазированную [ваш проект]_dev (на схеме - операция 2)
3. Перенос релизных веток в относительную точку, откуда они выходили до rebase'а [ваш проект]_dev (на схеме - операция 3)
4. Перенос тегов c релизных веток на новые позиции (на схеме - операция 4)
5. Перенос изменений на сервер
6. Обновление локально на других машинах
 
Схема, иллюстрирющая версионирование, тегирование и последовательность обновления до актуальной версии базового движка.

Последовательность обновления

Подготовительный этап

Перед основными этапами обновления (4 этапа, помечены на схеме) необходимо:
1. Обновление master ветки [ваш проект]:

- С использованием UI GitLab'а:
репозиторий BaseCodeMirror -> Merge Requests -> Create Merge Requests.
Подхватывает все коммиты на момент последнего обновления BaseCodeMirror.

- Ручной вариант:
Необходимо локально добавить upstream-репозиторий BaseCodeMirror:
> git remote add upstream [upstream-репозиторий]
2. Обновление ветки локально:

> git checkout master
> git pull
3. Перенос появившихся тегов BaseCode (делается независимо/отдельно от получения коммитов):

3.1. Подхватить теги вручную из BaseCodeMirror => [ваш проект]
> git fetch upstream --tags

3.2. Залить все теги на сервер
> git push --tags

Или же по каждому новому тегу:
> git push origin tag <tag_name>
Основной этап
0. (warning) Сохранение предыдущих позиций dev- и релизных веток (каждой)

Например, при обновлении до BaseCode-8.0.0 были сделаны бекапы (базировались на BaseCode-8.0.0-beta1):

[ваш проект]_dev_based_BaseCode_8.0.0-beta1
[ваш проект]_release-1.x.x.x_based_BaseCode-8.0.0-beta1


Это необходимо прежде всего для возможности откатиться к предыдущему положению веток.
Но не только: старые позиции веток нужны для возможности взять разницу между переносимой релизной и переносимой [ваш проект]_dev ветками.
1. Перенос [ваш проект]_dev на новую позицию (на схеме операция 1)

> git rebase [имя тега / хеш коммита] [ваш проект]_dev

Имя тега / хеш коммита должны указывать на коммит, куда переносится ветка.
Например, для переноса на версию BaseCode-8.0.0 команда выглядит так:

> git rebase BaseCode-8.0.0 [ваш проект]_dev

В результате rebase'а ожидаются конфликты, которые необходимо разрешить.
2. Перенос тегов c ветки [ваш проект]_dev_based_BaseCode_8.0.0-beta1 на новую перебазированную [ваш проект]_dev

Необходимо делать до этапа 3, чтобы переносить релизные ветки в нужные места перебазированной [ваш проект]_dev.

Коротко суть: определить очередной тег [ваш проект], идя вниз по дереву, и поставить на новое место.

Последовательность действий:

2.1. Имя очередного тега для переноса:
> git describe --abbrev=0 => получить первый тег вниз по дереву без доп.информации по тегу (хеш самого тега, количество коммитов от точки поиска и т.д.)

Если имя тега == "[ваш проект]-*", то работаем с ним и идём дальше по пунктам.
Если имя тега == "BaseCode-*", то уже дошли до корня (коммит базового движка) - переходим к пункту 3.

2.2. Удалить тег со старой позиции (или сделать командой переноса на пункте 2.4.)

> git tag -d [имя тега]

2.3. Определить новое место тега на перебазированной [ваш проект]_dev.

Можно полагаться на:

    Commit message
    Количество коммитов от начала ветки, например (лучшая подходящая команда):
    > git rev-list --count "$tag"..[имя ветки, с которой переносятся коммиты]

2.4. Поместить тег на новую позицию:

Если тег был удалён в п.2.2.:
> git tag -a [имя тега] [новая позиция тега] -m "[Предыдущее сообщение тега]"

Перенос одной командой, если не был удалён с добавлением флага -f:
> git tag -af [имя тега] [новая позиция тега]  => в таком случае сообщение тега можно модифицировать при переносе, если необходимо

(plus) Перенос тегов подлежит автоматизации с помощью скрипта
3. Перенос релизных веток в относительную точку, откуда они выходили до rebase'а [ваш проект]_dev

Ключевая команда:

> git rebase --reapply-cherry-picks --onto \[релизный тег] \[[ваш проект]_dev до rebase'а] \[переносимая ветка]

Например, для перехода с версии BaseCode-8.0.0-beta1 на BaseCode-8.0.0 команда следующая:
> git rebase --reapply-cherry-picks --onto [ваш проект]-1.0.0.0 [ваш проект]_dev_based_BaseCode_8.0.0-beta1 [ваш проект]_release-1.x.x.x_based_BaseCode-8.0.0-beta1

Флаг --reapply-cherry-picks необходим, чтобы при rebase'е были учтены коммиты, которые были подхвачены cherry-pick'ом из [ваш проект]_dev. Без этого флага коммиты могут быть пропущены.

Примечание:
Перед переносом можно проверить, какие коммиты будут перенесены:
> git log --oneline [ваш проект]_dev_based_BaseCode_8.0.0-beta1..[ваш проект]_release-1.x.x.x_based_BaseCode-8.0.0-beta1
4. Перенос тегов c релизных веток на новые позиции

Аналогично пункту два. Для каждой релизной ветки.
5. Перенос изменений на сервер

5.1. Перенос dev-ветки:
> git push -f origin [ваш проект]_dev

5.2. Перенос релизных веток. Для каждой релизной ветки:
> git push -f origin [ваш проект]_release-1.x.x.x

5.3. Потом теги:
> git push -f origin --tags
6. Обновление локально на других машинах

6.1. Обновление dev-ветки:
> git checkout [ваш проект]_dev
> git pull --rebase

6.2. Обновление релизной ветки:
> git checkout [ваш проект]_release-1.x.x.x
> git pull --rebase

6.3. Подхватить обновлённые теги:
> git fetch --tags --force